mod cache;
mod core;
mod emitter;
mod files;
mod schema;
#[cfg(test)]
mod tests;
mod utils;
mod watcher;

use core::core_state::CoreStateManager;
use std::{collections::HashMap, path::PathBuf};

use cache::query::{
    get_all_folders, get_all_folders_by_schema, get_all_tags, get_files_by_path,
    FolderListGetResult, RecordFromDb, RecordListGetResult,
};
use files::read_save::{
    read_file_by_path, save_file, FileReadMode, RecordReadResult, RecordSaveResult,
};
use schema::schema_cache::SchemaResult;
use schema::types::Schema;
use serde::Serialize;
use tauri::test::{mock_builder, MockRuntime};
use tauri::{AppHandle, Manager};
use tokio::fs::create_dir;
use tokio::runtime::Runtime;
use ts_rs::TS;
use utils::errorhandling::ErrFR;

use crate::cache::dbconn::InitMode;
use crate::files::utils::get_unique_path;
use crate::utils::helpers::{get_breadcrumb_items, normalize_path_to_os, FileBreadCrumbs};

/*
  Define types and pack them into IPCResponces, which gets exported to TS types
*/

#[derive(TS, Serialize)]
#[ts(export)]
struct IPCReadFileByPathResult {
    record: RecordReadResult,
    breadcrumb_items: FileBreadCrumbs,
}

type IPCInit = Result<Option<String>, Box<ErrFR>>;
type IPCGetFilesPath = Result<RecordListGetResult, Box<ErrFR>>;
type IPCGetRootPath = Result<Option<String>, Box<ErrFR>>;
type IPCSetRootPath = Result<String, Box<ErrFR>>;
type IPCGetAllTags = Result<Vec<String>, Box<ErrFR>>;
type IPCGetAllFolders = Result<FolderListGetResult, Box<ErrFR>>;
type IPCGetAllFoldersBySchema = Result<FolderListGetResult, Box<ErrFR>>;
type IPCReadFileByPath = Result<IPCReadFileByPathResult, Box<ErrFR>>;
type IPCGetSchemas = Result<HashMap<String, Schema>, Box<ErrFR>>;
type IPCLoadSchema = Result<Schema, Box<ErrFR>>;
type IPCSaveSchema = Result<Schema, Box<ErrFR>>;
type IPCSaveFile = Result<RecordSaveResult, Box<ErrFR>>;
type IPCResolveSchemaPath = Result<Option<SchemaResult>, Box<ErrFR>>;
type IPCDeleteFile = Result<(), Box<ErrFR>>;
type IPCCreateFolderForDefaultSchema = Result<PathBuf, Box<ErrFR>>;
#[derive(TS)]
#[ts(export)]
#[allow(dead_code)]
struct IPCResponces {
    /* These types are visible on frontend (generated by ts-rs from this struct content) */
    c_init: IPCInit,
    c_get_root_path: IPCGetRootPath,
    c_set_root_path_and_reinit: IPCSetRootPath,
    c_get_files_by_path: IPCGetFilesPath,
    c_get_all_tags: IPCGetAllTags,
    c_get_all_folders: IPCGetAllFolders,
    c_get_all_folders_by_schema: IPCGetAllFoldersBySchema,
    c_read_file_by_path: IPCReadFileByPath,
    c_get_schemas_usable: IPCGetSchemas,
    c_get_schemas_all: IPCGetSchemas,
    c_load_schema: IPCLoadSchema,
    c_save_schema: IPCSaveSchema,
    c_save_file: IPCSaveFile,
    c_resolve_schema_path: IPCResolveSchemaPath,
    c_delete_to_trash: IPCDeleteFile,
    c_create_folder_for_default_schema: IPCCreateFolderForDefaultSchema,
}

#[tauri::command]
async fn c_init<T: tauri::Runtime>(app: AppHandle<T>) -> IPCInit {
    log::info!("c_init invoked");
    let core = app.state::<CoreStateManager>();
    core.initiazize_on_root_path_from_disk(&app).await?;
    Ok(core.context.cached_root_path().await)
}

#[tauri::command]
async fn c_get_root_path<T: tauri::Runtime>(app: AppHandle<T>) -> IPCGetRootPath {
    log::info!("c_get_root_path invoked");
    let core = app.state::<CoreStateManager>();
    Ok(core.context.root_path_option().await)
}

#[tauri::command]
async fn c_set_root_path_and_reinit<T: tauri::Runtime>(
    app: AppHandle<T>,
    path: String,
) -> IPCSetRootPath {
    log::info!("c_set_root_path_and_reinit invoked");
    let core = app.state::<CoreStateManager>();
    let res = core.set_root_path_and_reinit(&app, path).await?;
    Ok(res)
}

#[tauri::command]
async fn c_get_files_by_path<T: tauri::Runtime>(
    app: AppHandle<T>,
    path_relative: String,
) -> IPCGetFilesPath {
    log::info!("c_get_files_by_path invoked");
    let core = app.state::<CoreStateManager>();
    let normalized_path = normalize_path_to_os(&path_relative);
    get_files_by_path(&core.context, &normalized_path).await
}

#[tauri::command]
async fn c_get_all_tags<T: tauri::Runtime>(app: AppHandle<T>) -> IPCGetAllTags {
    log::info!("c_get_all_tags invoked");
    let core = app.state::<CoreStateManager>();
    get_all_tags(&core.context)
        .await
        .map_err(|e| Box::new(ErrFR::new("Error when getting all tags").raw(e)))
}

#[tauri::command]
async fn c_get_all_folders<T: tauri::Runtime>(app: AppHandle<T>) -> IPCGetAllFolders {
    log::info!("c_get_all_folders invoked");
    let core = app.state::<CoreStateManager>();
    get_all_folders(&core.context).await
}

#[tauri::command]
async fn c_get_all_folders_by_schema<T: tauri::Runtime>(
    app: AppHandle<T>,
    schema_path: String,
) -> IPCGetAllFoldersBySchema {
    let core = app.state::<CoreStateManager>();
    log::info!("c_get_all_folders_by_schema invoked");
    let normalized_path = normalize_path_to_os(&schema_path);
    get_all_folders_by_schema(&core.context, &normalized_path).await
}

#[tauri::command]
async fn c_read_file_by_path<T: tauri::Runtime>(
    app: AppHandle<T>,
    path: String,
) -> IPCReadFileByPath {
    log::info!("c_read_file_by_path invoked");
    let core = app.state::<CoreStateManager>();
    let normalized_path = normalize_path_to_os(&path);
    let file = read_file_by_path(&core.context, &normalized_path, FileReadMode::FullFile).await?;
    let breadcrumb_items = get_breadcrumb_items(&file);
    Ok(IPCReadFileByPathResult {
        record: file,
        breadcrumb_items,
    })
}

#[tauri::command]
async fn c_get_schemas_all<T: tauri::Runtime>(app: AppHandle<T>) -> IPCGetSchemas {
    log::info!("c_get_schemas_all invoked");
    let core = app.state::<CoreStateManager>();
    let schemas = core
        .context
        .schemas_cache
        .get_schemas_list_with_empty()
        .await;
    Ok(schemas)
}

// This one returns only schemas with items
#[tauri::command]
async fn c_get_schemas_usable<T: tauri::Runtime>(app: AppHandle<T>) -> IPCGetSchemas {
    log::info!("c_get_schemas_usable invoked");
    let core = app.state::<CoreStateManager>();
    let schemas = core.context.schemas_cache.get_schemas_list().await;
    Ok(schemas)
}

#[tauri::command]
async fn c_load_schema<T: tauri::Runtime>(app: AppHandle<T>, path: String) -> IPCLoadSchema {
    log::info!("c_load_schema invoked");
    let core = app.state::<CoreStateManager>();
    let ctx = &core.context;

    let normalized_path = normalize_path_to_os(&path);

    // TODO?: This reads schema from disk, not sure if this needed really
    match core
        .context
        .schemas_cache
        .cache_schema_absolute_path(ctx, ctx.relative_path_to_absolute(&normalized_path).await?)
        .await
    {
        Ok(Some(v)) => Ok(v),
        Ok(None) => Err(Box::new(ErrFR::new("Schema not found").info(&path))),
        Err(e) => Err(e),
    }
}

#[tauri::command]
async fn c_save_schema<T: tauri::Runtime>(
    app: AppHandle<T>,
    path: String,
    schema: Schema,
) -> IPCSaveSchema {
    log::info!("c_save_schema invoked");
    let core = app.state::<CoreStateManager>();
    let ctx = &core.context;
    let normalized_path = normalize_path_to_os(&path);
    core.context
        .schemas_cache
        .save_schema(ctx, &normalized_path, schema)
        .await
}

#[tauri::command]
async fn c_save_file<T: tauri::Runtime>(
    app: AppHandle<T>,
    record: RecordFromDb,
    forced: bool,
    create_new: bool,
) -> IPCSaveFile {
    log::info!("c_save_file invoked");
    let core = app.state::<CoreStateManager>();
    save_file(&core.context, record, forced, create_new).await
}

#[tauri::command]
async fn c_resolve_schema_path<T: tauri::Runtime>(
    app: AppHandle<T>,
    path: String,
) -> IPCResolveSchemaPath {
    log::info!("c_resolve_schema_path invoked");
    let core = app.state::<CoreStateManager>();
    Ok(core
        .context
        .schemas_cache
        .get_schema(&PathBuf::from(path))
        .await)
}

#[tauri::command]
async fn c_delete_to_trash<T: tauri::Runtime>(app: AppHandle<T>, path: String) -> IPCDeleteFile {
    log::info!("c_delete_to_trash invoked");
    let core = app.state::<CoreStateManager>();
    let absolute_path = core
        .context
        .relative_path_to_absolute(&PathBuf::from(path))
        .await?;
    trash::delete(&absolute_path).map_err(|e| Box::new(ErrFR::new("Failed to delete file").raw(e)))
}

#[tauri::command]
async fn c_create_folder_for_default_schema<T: tauri::Runtime>(
    app: AppHandle<T>,
    path: String,
) -> IPCCreateFolderForDefaultSchema {
    log::info!("c_create_folder_for_default_schema invoked");
    let core = app.state::<CoreStateManager>();
    let path_absolute = core
        .context
        .relative_path_to_absolute(&PathBuf::from(path))
        .await?;

    let not_existing = get_unique_path(&path_absolute);

    create_dir(&not_existing)
        .await
        .map_err(|e| Box::new(ErrFR::new("Failed to create folder").raw(e)))?;

    let relative_path = core
        .context
        .absolute_path_to_relative(&not_existing)
        .await?;
    Ok(relative_path)
}

pub fn create_app<T: tauri::Runtime>(builder: tauri::Builder<T>) -> tauri::App<T> {
    builder
        .plugin(tauri_plugin_sql::Builder::new().build())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_store::Builder::new().build())
        .invoke_handler(tauri::generate_handler![
            c_init,
            c_get_root_path,
            c_set_root_path_and_reinit,
            c_load_schema,
            c_save_schema,
            c_get_files_by_path,
            c_get_all_tags,
            c_get_all_folders,
            c_get_all_folders_by_schema,
            c_read_file_by_path,
            c_save_file,
            c_get_schemas_usable,
            c_get_schemas_all,
            c_resolve_schema_path,
            c_delete_to_trash,
            c_create_folder_for_default_schema
        ])
        .setup(|app| {
            log::info!("Setting up app");

            #[cfg(not(debug_assertions))]
            {
                log_plugin = log_plugin;
                app.handle().plugin(
                    tauri_plugin_log::Builder::default()
                        .level(log::LevelFilter::Info)
                        .max_file_size(5 * 1024 * 1024) // 5MB
                        .rotation_strategy(tauri_plugin_log::RotationStrategy::KeepSome(3))
                        .target(tauri_plugin_log::Target::new(
                            tauri_plugin_log::TargetKind::LogDir {
                                file_name: Some("logs".to_string()),
                            },
                        ))
                        .build(),
                )?;
            }

            #[cfg(debug_assertions)]
            {
                app.handle().plugin(
                    tauri_plugin_log::Builder::default()
                        .level(log::LevelFilter::Info)
                        .build(),
                )?;
            }

            let mut state = CoreStateManager::new(app.handle().clone());
            let rt = Runtime::new().unwrap();
            rt.block_on(async {
                let cache_dir = app.path().cache_dir().unwrap();
                let _ = state
                    .context
                    .database_conn
                    .init(InitMode::InFolder(cache_dir))
                    .await;
            });

            app.manage(state);
            Ok(())
        })
        .build(tauri::generate_context!())
        .expect("error while running tauri application")
}

pub fn run() {
    create_app(
        tauri::Builder::default()
            .plugin(tauri_plugin_process::init())
            .plugin(tauri_plugin_updater::Builder::new().build())
            .plugin(tauri_plugin_http::init())
            .plugin(tauri_plugin_opener::init())
            .plugin(tauri_plugin_os::init()),
    )
    .run(|_, _| {});
}

pub fn create_mock_app() -> tauri::App<MockRuntime> {
    create_app(mock_builder())
}
